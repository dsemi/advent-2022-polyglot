(format t "Day 20: Common Lisp~%")

(defstruct node
  (val 0 :type fixnum)
  (prev nil :type (or node null))
  (next nil :type (or node null))
  (far-prev nil :type (or node null))
  (far-next nil :type (or node null)))

(defun read-ns ()
  (loop for line = (read-line *standard-input* nil nil)
        while line
        collect (parse-integer line)))

(defun mix (nums times)
  (let* ((ns (make-array (length nums) :initial-contents (mapcar (lambda (n) (make-node :val n)) nums)))
         (skip-size (/ (isqrt (/ (length ns) 2)) 2))
         (m (1- (length ns))))
    (loop for i from 0 below (length ns)
          do (setf (node-prev (aref ns (mod (1+ i) (1+ m)))) (aref ns i))
          do (setf (node-next (aref ns i)) (aref ns (mod (1+ i) (1+ m))))
          do (setf (node-far-prev (aref ns (mod (+ skip-size i) (1+ m)))) (aref ns i))
          do (setf (node-far-next (aref ns i)) (aref ns (mod (+ skip-size i) (1+ m)))))
    (loop repeat times
          do (loop for n across ns
                   do (let ((a (node-far-prev n))
                            (b (node-next n)))
                        (setf (node-next (node-prev n)) (node-next n))
                        (setf (node-prev (node-next n)) (node-prev n))
                        (loop repeat (1+ skip-size)
                              do (setf (node-far-next a) b)
                              do (setf (node-far-prev b) a)
                              do (setf a (node-next a))
                              do (setf b (node-next b)))
                        (setf b (node-next n))
                        (let (far-step step (to-move (mod (node-val n) m)))
                          (if (> to-move (/ m 2))
                              (progn (setf to-move (- m to-move))
                                     (setf far-step (lambda (x) (node-far-prev x)))
                                     (setf step (lambda (x) (node-prev x))))
                              (progn (setf far-step (lambda (x) (node-far-next x)))
                                     (setf step (lambda (x) (node-next x)))))
                          (loop while (>= to-move skip-size)
                                do (setf to-move (- to-move skip-size))
                                do (setf b (funcall far-step b)))
                          (loop repeat to-move
                                do (setf b (funcall step b))))
                        (setf (node-next (node-prev b)) n)
                        (setf (node-prev n) (node-prev b))
                        (setf (node-prev b) n)
                        (setf (node-next n) b)
                        (setf a (node-far-prev b))
                        (setf b n)
                        (loop repeat (1+ skip-size)
                              do (setf (node-far-next a) b)
                              do (setf (node-far-prev b) a)
                              do (setf a (node-next a))
                              do (setf b (node-next b))))))
    (let ((cur (loop for n across ns
                     when (= (node-val n) 0)
                     return n)))
      (loop for i from 1 to 3000
            do (setf cur (node-next cur))
            when (= 0 (mod i 1000)) sum (node-val cur)))))

(let* ((ns (read-ns)))
  (format t "Part 1: ~20d~%" (mix ns 1))
  (format t "Part 2: ~20d~%" (mix (mapcar (lambda (n) (* n 811589153)) ns) 10)))
